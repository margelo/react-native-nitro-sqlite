diff --git a/node_modules/release-it/README.md b/node_modules/release-it/README.md
index 825b923..09e0041 100644
--- a/node_modules/release-it/README.md
+++ b/node_modules/release-it/README.md
@@ -60,10 +60,11 @@ npx release-it
 
 You will be prompted to select the new version, and more prompts will follow based on your configuration.
 
-## Yarn & pnpm
+## Yarn, Bun & pnpm
 
 - Using Yarn? Please see the [npm section on Yarn][15].
-- Using pnpm? Please see [release-it-pnpm][16].
+- Using pnpm? Please see [release-it-bun][16].
+- Using pnpm? Please see [release-it-pnpm][17].
 
 ## Monorepos
 
@@ -305,7 +306,8 @@ Since v11, release-it can be extended in many, many ways. Here are some plugins:
 | [@grupoboticario/news-fragments][45]      | An easy way to generate your changelog file                                                 |
 | [@j-ulrich/release-it-regex-bumper][46]   | Regular expression based version read/write plugin for release-it                           |
 | [@jcamp-code/release-it-dotnet][47]       | Use .csproj or .props file for versioning, automate NuGet publishing                        |
-| [release-it-pnpm][16]                     | Add basic support for pnpm workspaces, integrates with [bumpp][48] and [changelogithub][49] |
+| [release-it-bun][16]                     | Add basic support for Bun workspaces, integrates with [bumpp][48] and [changelogithub][49] |
+| [release-it-pnpm][17]                     | Add basic support for pnpm workspaces, integrates with [bumpp][48] and [changelogithub][49] |
 | [changesets-release-it-plugin][50]        | Combine [Changesets][51] changelog management with release-it                               |
 
 Internally, release-it uses its own plugin architecture (for Git, GitHub, GitLab, npm).
@@ -374,7 +376,8 @@ Are you using release-it at work? Please consider [sponsoring me][14]!
 [13]: https://badge.fury.io/js/release-it.svg
 [14]: https://github.com/sponsors/webpro
 [15]: ./docs/npm.md#yarn
-[16]: https://github.com/hyoban/release-it-pnpm
+[16]: https://github.com/hyoban/release-it-bun
+[17]: https://github.com/hyoban/release-it-pnpm
 [17]: ./docs/recipes/monorepo.md
 [18]: https://github.com/juancarlosjr97/release-it-containerized
 [19]: https://github.com/juancarlosjr97
diff --git a/node_modules/release-it/config/release-it.json b/node_modules/release-it/config/release-it.json
index 729cc6e..e1f1315 100644
--- a/node_modules/release-it/config/release-it.json
+++ b/node_modules/release-it/config/release-it.json
@@ -20,7 +20,9 @@
     "tagAnnotation": "Release ${version}",
     "tagArgs": [],
     "push": true,
-    "pushArgs": ["--follow-tags"],
+    "pushArgs": [
+      "--follow-tags"
+    ],
     "pushRepo": ""
   },
   "npm": {
@@ -35,6 +37,18 @@
     "skipChecks": false,
     "timeout": 10
   },
+  "bun": {
+    "publish": false,
+    "publishPath": ".",
+    "publishArgs": [],
+    "tag": null,
+    "otp": null,
+    "ignoreVersion": false,
+    "allowSameVersion": false,
+    "versionArgs": [],
+    "skipChecks": false,
+    "timeout": 10
+  },
   "github": {
     "release": false,
     "releaseName": "Release ${version}",
diff --git a/node_modules/release-it/lib/config.js b/node_modules/release-it/lib/config.js
index 025dc40..f9e4a7a 100644
--- a/node_modules/release-it/lib/config.js
+++ b/node_modules/release-it/lib/config.js
@@ -67,6 +67,7 @@ class Config {
       options.git.requireBranch = '!main';
       options.git.requireUpstream = false;
       options.npm.ignoreVersion = true;
+      options.bun.ignoreVersion = true;
     }
     return options;
   }
diff --git a/node_modules/release-it/lib/plugin/bun/bun.js b/node_modules/release-it/lib/plugin/bun/bun.js
new file mode 100644
index 0000000..99dd67d
--- /dev/null
+++ b/node_modules/release-it/lib/plugin/bun/bun.js
@@ -0,0 +1,281 @@
+import path from 'node:path';
+import semver from 'semver';
+import urlJoin from 'url-join';
+import Plugin from '../Plugin.js';
+import { hasAccess, rejectAfter, parseVersion, readJSON, e } from '../../util.js';
+import prompts from './prompts.js';
+
+const docs = 'https://git.io/release-it-bun';
+
+const options = { write: false };
+
+const MANIFEST_PATH = './package.json';
+const DEFAULT_TAG = 'latest';
+const DEFAULT_TAG_PRERELEASE = 'next';
+const NPM_BASE_URL = 'https://www.npmjs.com';
+const NPM_PUBLIC_PATH = '/package';
+
+const fixArgs = args => (args ? (typeof args === 'string' ? args.split(' ') : args) : []);
+
+class bun extends Plugin {
+  static isEnabled(options) {
+    return hasAccess(MANIFEST_PATH) && options !== false;
+  }
+
+  constructor(...args) {
+    super(...args);
+    this.registerPrompts(prompts);
+  }
+
+  async init() {
+    const { name, version: latestVersion, private: isPrivate, publishConfig } = readJSON(path.resolve(MANIFEST_PATH));
+    this.setContext({ name, latestVersion, private: isPrivate, publishConfig });
+    this.config.setContext({ bun: { name } });
+
+    const { publish, skipChecks } = this.options;
+
+    const timeout = Number(this.options.timeout) * 1000;
+
+    if (publish === false || isPrivate) return;
+
+    if (skipChecks) return;
+
+    const validations = Promise.all([this.isRegistryUp(), this.isAuthenticated(), this.getLatestRegistryVersion()]);
+
+    await Promise.race([validations, rejectAfter(timeout, e(`Timed out after ${timeout}ms.`, docs))]);
+
+    const [isRegistryUp, isAuthenticated, latestVersionInRegistry] = await validations;
+
+    if (!isRegistryUp) {
+      throw e(`Unable to reach bun registry (timed out after ${timeout}ms).`, docs);
+    }
+
+    if (!isAuthenticated) {
+      throw e('Not authenticated with bun. Please `bun login` and try again.', docs);
+    }
+
+    if (!(await this.isCollaborator())) {
+      const { username } = this.getContext();
+      throw e(`User ${username} is not a collaborator for ${name}.`, docs);
+    }
+
+    if (!latestVersionInRegistry) {
+      this.log.warn('No version found in bun registry. Assuming new package.');
+    } else {
+      if (!semver.eq(latestVersion, latestVersionInRegistry)) {
+        this.log.warn(
+          `Latest version in registry (${latestVersionInRegistry}) does not match package.json (${latestVersion}).`
+        );
+      }
+    }
+  }
+
+  getName() {
+    return this.getContext('name');
+  }
+
+  getLatestVersion() {
+    return this.options.ignoreVersion ? null : this.getContext('latestVersion');
+  }
+
+  async bump(version) {
+    const tag = this.options.tag || (await this.resolveTag(version));
+    this.setContext({ version, tag });
+
+    if (!this.config.isIncrement) return false;
+
+    const { versionArgs, allowSameVersion } = this.options;
+    const args = [version, '--no-git-tag-version', allowSameVersion && '--allow-same-version', ...fixArgs(versionArgs)];
+    const task = () => this.exec(`bun version ${args.filter(Boolean).join(' ')}`);
+    return this.spinner.show({ task, label: 'bun version' });
+  }
+
+  release() {
+    if (this.options.publish === false) return false;
+    if (this.getContext('private')) return false;
+    const publish = () => this.publish({ otpCallback });
+    const otpCallback =
+      this.config.isCI && !this.config.isPromptOnlyVersion ? null : task => this.step({ prompt: 'otp', task });
+    return this.step({ task: publish, label: 'bun publish', prompt: 'publish' });
+  }
+
+  isRegistryUp() {
+    const registry = this.getRegistry();
+    const registryArg = registry ? ` --registry ${registry}` : '';
+    return this.exec(`bun ping${registryArg}`, { options }).then(
+      () => true,
+      err => {
+        if (/code E40[04]|404.*(ping not found|No content for path)/.test(err)) {
+          this.log.warn('Ignoring response from unsupported `bun ping` command.');
+          return true;
+        }
+        return false;
+      }
+    );
+  }
+
+  isAuthenticated() {
+    const registry = this.getRegistry();
+    const registryArg = registry ? ` --registry ${registry}` : '';
+    return this.exec(`bun whoami${registryArg}`, { options }).then(
+      output => {
+        const username = output ? output.trim() : null;
+        this.setContext({ username });
+        return true;
+      },
+      err => {
+        this.debug(err);
+        if (/code E40[04]/.test(err)) {
+          this.log.warn('Ignoring response from unsupported `bun whoami` command.');
+          return true;
+        }
+        return false;
+      }
+    );
+  }
+
+  async isCollaborator() {
+    const registry = this.getRegistry();
+    const registryArg = registry ? ` --registry ${registry}` : '';
+    const name = this.getName();
+    const { username } = this.getContext();
+    if (username === undefined) return true;
+    if (username === null) return false;
+
+    try {
+      let bunVersion = await this.exec('bun --version', { options });
+
+      let accessCommand;
+      if (semver.gt(bunVersion, '9.0.0')) {
+        accessCommand = 'bun access list collaborators --json';
+      } else {
+        accessCommand = 'bun access ls-collaborators';
+      }
+
+      const output = await this.exec(`${accessCommand} ${name}${registryArg}`, { options });
+
+      try {
+        const collaborators = JSON.parse(output);
+        const permissions = collaborators[username];
+        return permissions && permissions.includes('write');
+      } catch (err) {
+        this.debug(err);
+        return false;
+      }
+    } catch (err) {
+      this.debug(err);
+      if (/code E400/.test(err)) {
+        this.log.warn('Ignoring response from unsupported `bun access` command.');
+      } else {
+        this.log.warn(`Unable to verify if user ${username} is a collaborator for ${name}.`);
+      }
+      return true;
+    }
+  }
+
+  async getLatestRegistryVersion() {
+    const registry = this.getRegistry();
+    const registryArg = registry ? ` --registry ${registry}` : '';
+    const name = this.getName();
+    const latestVersion = this.getLatestVersion();
+    const tag = await this.resolveTag(latestVersion);
+    return this.exec(`bun show ${name}@${tag} version${registryArg}`, { options }).catch(() => null);
+  }
+
+  getRegistryPreReleaseTags() {
+    return this.exec(`bun view ${this.getName()} dist-tags --json`, { options }).then(
+      output => {
+        try {
+          const tags = JSON.parse(output);
+          return Object.keys(tags).filter(tag => tag !== DEFAULT_TAG);
+        } catch (err) {
+          this.debug(err);
+          return [];
+        }
+      },
+      () => []
+    );
+  }
+
+  getPackageUrl() {
+    const baseUrl = this.getRegistry() || NPM_BASE_URL;
+    const publicPath = this.getPublicPath() || NPM_PUBLIC_PATH;
+    return urlJoin(baseUrl, publicPath, this.getName());
+  }
+
+  getRegistry() {
+    const { publishConfig } = this.getContext();
+    const registries = publishConfig
+      ? publishConfig.registry
+        ? [publishConfig.registry]
+        : Object.keys(publishConfig)
+            .filter(key => key.endsWith('registry'))
+            .map(key => publishConfig[key])
+      : [];
+    return registries[0];
+  }
+
+  getPublicPath() {
+    const { publishConfig } = this.getContext();
+    return (publishConfig && publishConfig.publicPath) ?? '';
+  }
+
+  async guessPreReleaseTag() {
+    const [tag] = await this.getRegistryPreReleaseTags();
+    if (tag) {
+      return tag;
+    } else {
+      this.log.warn(`Unable to get pre-release tag(s) from bun registry. Using "${DEFAULT_TAG_PRERELEASE}".`);
+      return DEFAULT_TAG_PRERELEASE;
+    }
+  }
+
+  async resolveTag(version) {
+    const { tag } = this.options;
+    const { isPreRelease, preReleaseId } = parseVersion(version);
+    if (!isPreRelease) {
+      return DEFAULT_TAG;
+    } else {
+      return tag || preReleaseId || (await this.guessPreReleaseTag());
+    }
+  }
+
+  async publish({ otp = this.options.otp, otpCallback } = {}) {
+    const { publishPath = '.', publishArgs } = this.options;
+    const { private: isPrivate, tag = DEFAULT_TAG } = this.getContext();
+    const otpArg = otp ? `--otp ${otp}` : '';
+    const dryRunArg = this.config.isDryRun ? '--dry-run' : '';
+    const registry = this.getRegistry();
+    const registryArg = registry ? `--registry ${registry}` : '';
+    if (isPrivate) {
+      this.log.warn('Skip publish: package is private.');
+      return false;
+    }
+    const args = [publishPath, `--tag ${tag}`, otpArg, dryRunArg, registryArg, ...fixArgs(publishArgs)].filter(Boolean);
+    return this.exec(`bun publish ${args.join(' ')}`, { options })
+      .then(() => {
+        this.setContext({ isReleased: true });
+      })
+      .catch(err => {
+        this.debug(err);
+        if (/one-time pass/.test(err)) {
+          if (otp != null) {
+            this.log.warn('The provided OTP is incorrect or has expired.');
+          }
+          if (otpCallback) {
+            return otpCallback(otp => this.publish({ otp, otpCallback }));
+          }
+        }
+        throw err;
+      });
+  }
+
+  afterRelease() {
+    const { isReleased } = this.getContext();
+    if (isReleased) {
+      this.log.log(`🔗 ${this.getPackageUrl()}`);
+    }
+  }
+}
+
+export default bun;
diff --git a/node_modules/release-it/lib/plugin/bun/prompts.js b/node_modules/release-it/lib/plugin/bun/prompts.js
new file mode 100644
index 0000000..0454f34
--- /dev/null
+++ b/node_modules/release-it/lib/plugin/bun/prompts.js
@@ -0,0 +1,12 @@
+export default {
+  publish: {
+    type: 'confirm',
+    message: context =>
+      `Publish ${context.bun.name}${context.bun.tag === 'latest' ? '' : `@${context.bun.tag}`} to bun?`,
+    default: true
+  },
+  otp: {
+    type: 'input',
+    message: () => `Please enter OTP for bun:`
+  }
+};
diff --git a/node_modules/release-it/lib/plugin/factory.js b/node_modules/release-it/lib/plugin/factory.js
index 53ea22e..b893d87 100644
--- a/node_modules/release-it/lib/plugin/factory.js
+++ b/node_modules/release-it/lib/plugin/factory.js
@@ -8,17 +8,19 @@ import Git from './git/Git.js';
 import GitLab from './gitlab/GitLab.js';
 import GitHub from './github/GitHub.js';
 import npm from './npm/npm.js';
+import bun from './bun/bun.js';
 
 const debug = util.debug('release-it:plugins');
 
-const pluginNames = ['npm', 'git', 'github', 'gitlab', 'version'];
+const pluginNames = ['npm', 'bun', 'git', 'github', 'gitlab', 'version'];
 
 const plugins = {
   version: Version,
   git: Git,
   gitlab: GitLab,
   github: GitHub,
-  npm: npm
+  npm: npm,
+  bun: bun
 };
 
 const load = async pluginName => {
diff --git a/node_modules/release-it/schema/bun.json b/node_modules/release-it/schema/bun.json
new file mode 100644
index 0000000..afe8233
--- /dev/null
+++ b/node_modules/release-it/schema/bun.json
@@ -0,0 +1,57 @@
+{
+  "$schema": "http://json-schema.org/draft-07/schema",
+  "$id": "release-it#bun",
+  "title": "JSON schema for release-it bun configuration",
+  "type": "object",
+  "additionalItems": false,
+  "properties": {
+    "publish": {
+      "type": "boolean",
+      "default": false
+    },
+    "publishPath": {
+      "type": "string",
+      "default": "."
+    },
+    "publishArgs": {
+      "type": "array",
+      "uniqueItems": true,
+      "items": {
+        "type": "string"
+      },
+      "default": []
+    },
+    "tag": {
+      "type": "string",
+      "default": null
+    },
+    "otp": {
+      "type": "string",
+      "default": null
+    },
+    "ignoreVersion": {
+      "type": "boolean",
+      "default": false
+    },
+    "allowSameVersion": {
+      "type": "boolean",
+      "default": false
+    },
+    "versionArgs": {
+      "type": "array",
+      "uniqueItems": true,
+      "items": {
+        "type": "string"
+      },
+      "default": []
+    },
+    "skipChecks": {
+      "type": "boolean",
+      "default": false
+    },
+    "timeout": {
+      "type": "integer",
+      "default": 10
+    }
+  }
+}
diff --git a/node_modules/release-it/schema/release-it.json b/node_modules/release-it/schema/release-it.json
index c8cbeca..1c1c13f 100644
--- a/node_modules/release-it/schema/release-it.json
+++ b/node_modules/release-it/schema/release-it.json
@@ -59,6 +59,19 @@
         "default": false
       }
     },
+    "bun": {
+      "$comment": "Boolean or bun config object",
+      "if": {
+        "type": "object"
+      },
+      "then": {
+        "$ref": "./bun.json"
+      },
+      "else": {
+        "type": "boolean",
+        "default": false
+      }
+    },
     "github": {
       "$comment": "Boolean or github config object",
       "if": {
diff --git a/node_modules/release-it/test/bun.js b/node_modules/release-it/test/bun.js
new file mode 100644
index 0000000..927f6d9
--- /dev/null
+++ b/node_modules/release-it/test/bun.js
@@ -0,0 +1,417 @@
+import path from 'node:path';
+import { patchFs } from 'fs-monkey';
+import test from 'ava';
+import sinon from 'sinon';
+import { vol } from 'memfs';
+import bun from '../lib/plugin/bun/bun.js';
+import { factory, runTasks } from 'release-it/test/util/index.js';
+import { getArgs } from './util/helpers.js';
+
+const mockFs = volume => {
+  vol.fromJSON(volume);
+  const unpatch = patchFs(vol);
+  return () => {
+    vol.reset();
+    unpatch();
+  };
+};
+
+test('should return bun package url', t => {
+  const options = { bun: { name: 'my-cool-package' } };
+  const bunClient = factory(bun, { options });
+  t.is(bunClient.getPackageUrl(), 'https://www.npmjs.com/package/my-cool-package');
+});
+
+test('should return bun package url (custom registry)', t => {
+  const options = { bun: { name: 'my-cool-package', publishConfig: { registry: 'https://registry.example.org/' } } };
+  const bunClient = factory(bun, { options });
+  t.is(bunClient.getPackageUrl(), 'https://registry.example.org/package/my-cool-package');
+});
+
+test('should return bun package url (custom publicPath)', t => {
+  const options = { bun: { name: 'my-cool-package', publishConfig: { publicPath: '/custom/public-path' } } };
+  const bunClient = factory(bun, { options });
+  t.is(bunClient.getPackageUrl(), 'https://www.npmjs.com/custom/public-path/my-cool-package');
+});
+
+test('should return bun package url (custom registry and publicPath)', t => {
+  const options = {
+    bun: {
+      name: 'my-cool-package',
+      publishConfig: { registry: 'https://registry.example.org/', publicPath: '/custom/public-path' }
+    }
+  };
+  const bunClient = factory(bun, { options });
+  t.is(bunClient.getPackageUrl(), 'https://registry.example.org/custom/public-path/my-cool-package');
+});
+
+test('should return default tag', async t => {
+  const bunClient = factory(bun);
+  const tag = await bunClient.resolveTag();
+  t.is(tag, 'latest');
+});
+
+test('should resolve default tag for pre-release', async t => {
+  const bunClient = factory(bun);
+  const stub = sinon.stub(bunClient, 'getRegistryPreReleaseTags').resolves([]);
+  const tag = await bunClient.resolveTag('1.0.0-0');
+  t.is(tag, 'next');
+  stub.restore();
+});
+
+test('should guess tag from registry for pre-release', async t => {
+  const bunClient = factory(bun);
+  const stub = sinon.stub(bunClient, 'getRegistryPreReleaseTags').resolves(['alpha']);
+  const tag = await bunClient.resolveTag('1.0.0-0');
+  t.is(tag, 'alpha');
+  stub.restore();
+});
+
+test('should derive tag from pre-release version', async t => {
+  const bunClient = factory(bun);
+  const tag = await bunClient.resolveTag('1.0.2-alpha.3');
+  t.is(tag, 'alpha');
+});
+
+test('should use provided (default) tag even for pre-release', async t => {
+  const options = { bun: { tag: 'latest' } };
+  const bunClient = factory(bun, { options });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  await bunClient.bump('1.0.0-next.0');
+  t.is(bunClient.getContext('tag'), 'latest');
+  exec.restore();
+});
+
+test('should throw when `bun version` fails', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon
+    .stub(bunClient.shell, 'exec')
+    .rejects(new Error('bun ERR! Version not changed, might want --allow-same-version'));
+
+  await t.throwsAsync(bunClient.bump('1.0.0-next.0'), { message: /Version not changed/ });
+
+  exec.restore();
+});
+
+test('should return first pre-release tag from package in registry when resolving tag without pre-id', async t => {
+  const bunClient = factory(bun);
+  const response = {
+    latest: '1.4.1',
+    alpha: '2.0.0-alpha.1',
+    beta: '2.0.0-beta.3'
+  };
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves(JSON.stringify(response));
+  t.is(await bunClient.resolveTag('2.0.0-5'), 'alpha');
+  exec.restore();
+});
+
+test('should return default pre-release tag when resolving tag without pre-id', async t => {
+  const bunClient = factory(bun);
+  const response = {
+    latest: '1.4.1'
+  };
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves(JSON.stringify(response));
+  t.is(await bunClient.resolveTag('2.0.0-0'), 'next');
+  exec.restore();
+});
+
+test('should handle erroneous output when resolving tag without pre-id', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves('');
+  t.is(await bunClient.resolveTag('2.0.0-0'), 'next');
+  exec.restore();
+});
+
+test('should handle errored request when resolving tag without pre-id', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').rejects();
+  t.is(await bunClient.resolveTag('2.0.0-0'), 'next');
+  exec.restore();
+});
+
+test('should add registry to commands when specified', async t => {
+  const bunClient = factory(bun);
+  bunClient.setContext({ publishConfig: { registry: 'registry.example.org' } });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami --registry registry.example.org').resolves('john');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) release-it --registry registry.example.org/)
+    .resolves(JSON.stringify({ john: ['write'] }));
+  await runTasks(bunClient);
+  t.is(exec.args[0][0], 'bun ping --registry registry.example.org');
+  t.is(exec.args[1][0], 'bun whoami --registry registry.example.org');
+  t.regex(exec.args[2][0], /bun show release-it@[a-z]+ version --registry registry\.example\.org/);
+  exec.restore();
+});
+
+test('should not throw when executing tasks', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').resolves('john');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) release-it/)
+    .resolves(JSON.stringify({ john: ['write'] }));
+  await t.notThrowsAsync(runTasks(bunClient));
+  exec.restore();
+});
+
+test('should throw if bun is down', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun ping').rejects();
+  await t.throwsAsync(runTasks(bunClient), { message: /^Unable to reach bun registry/ });
+  exec.restore();
+});
+
+test('should not throw if bun returns 400/404 for unsupported ping/whoami/access', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  const pingError = "bun ERR! code E404\nbun ERR! 404 Package '--ping' not found : ping";
+  const whoamiError = "bun ERR! code E404\nbun ERR! 404 Package '--whoami' not found : whoami";
+  const accessError = 'bun ERR! code E400\nbun ERR! 400 Bad Request - GET https://bun.example.org/-/collaborators';
+  exec.withArgs('bun ping').rejects(new Error(pingError));
+  exec.withArgs('bun whoami').rejects(new Error(whoamiError));
+  exec.withArgs('bun access').rejects(new Error(accessError));
+  await runTasks(bunClient);
+  t.is(exec.lastCall.args[0].trim(), 'bun publish . --tag latest');
+  exec.restore();
+});
+
+test('should not throw if bun returns 400 for unsupported ping/whoami/access', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  const pingError = 'bun ERR! code E400\nbun ERR! 400 Bad Request - GET https://bun.example.org/-/ping?write=true';
+  const whoamiError = 'bun ERR! code E400\nbun ERR! 400 Bad Request - GET https://bun.example.org/-/whoami';
+  const accessError = 'bun ERR! code E400\nbun ERR! 400 Bad Request - GET https://bun.example.org/-/collaborators';
+  exec.withArgs('bun ping').rejects(new Error(pingError));
+  exec.withArgs('bun whoami').rejects(new Error(whoamiError));
+  exec.withArgs('bun access').rejects(new Error(accessError));
+  await runTasks(bunClient);
+  t.is(exec.lastCall.args[0].trim(), 'bun publish . --tag latest');
+  exec.restore();
+});
+
+test('should not throw if bun returns 404 for unsupported ping', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  const pingError = 'bun ERR!     <title>404 - No content for path /-/ping</title>';
+  exec.withArgs('bun ping').rejects(new Error(pingError));
+  exec.withArgs('bun whoami').resolves('john');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) release-it/)
+    .resolves(JSON.stringify({ john: ['write'] }));
+  await runTasks(bunClient);
+  t.is(exec.lastCall.args[0].trim(), 'bun publish . --tag latest');
+  exec.restore();
+});
+
+test('should throw if user is not authenticated', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').rejects();
+  await t.throwsAsync(runTasks(bunClient), { message: /^Not authenticated with bun/ });
+  exec.restore();
+});
+
+test('should throw if user is not a collaborator (v9)', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').resolves('ada');
+  exec.withArgs('bun --version').resolves('9.2.0');
+  exec.withArgs('bun access list collaborators --json release-it').resolves(JSON.stringify({ john: ['write'] }));
+  await t.throwsAsync(runTasks(bunClient), { message: /^User ada is not a collaborator for release-it/ });
+  exec.restore();
+});
+
+test('should throw if user is not a collaborator (v8)', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').resolves('ada');
+  exec.withArgs('bun --version').resolves('8.2.0');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) release-it/)
+    .resolves(JSON.stringify({ john: ['write'] }));
+  await t.throwsAsync(runTasks(bunClient), { message: /^User ada is not a collaborator for release-it/ });
+  exec.restore();
+});
+
+test('should not throw if user is not a collaborator on a new package', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').resolves('ada');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) release-it/)
+    .rejects(
+      new Error(
+        'bun ERR! code E404\nbun ERR! 404 Not Found - GET https://registry.npmjs.org/-/package/release-it/collaborators?format=cli - File not found'
+      )
+    );
+  await t.notThrowsAsync(runTasks(bunClient));
+  exec.restore();
+});
+
+test('should publish a new private scoped package as bun would', async t => {
+  const options = { bun: { tag: 'beta' } };
+  const bunClient = factory(bun, { options });
+  bunClient.setContext({ name: '@scoped/pkg' });
+  const exec = sinon.spy(bunClient.shell, 'exec');
+  await bunClient.publish();
+  t.is(exec.lastCall.args[0].trim(), 'bun publish . --tag beta');
+  exec.restore();
+});
+
+test('should not publish private package', async t => {
+  const bunClient = factory(bun);
+  bunClient.setContext({ name: 'pkg', private: true });
+  const exec = sinon.spy(bunClient.shell, 'exec');
+  await bunClient.publish();
+  const publish = exec.args.filter(arg => arg[0].startsWith('bun publish'));
+  t.is(publish.length, 0);
+  t.regex(bunClient.log.warn.lastCall.args[0], /package is private/);
+});
+
+test('should handle 2FA and publish with OTP', async t => {
+  const bunClient = factory(bun);
+  bunClient.setContext({ name: 'pkg' });
+
+  const exec = sinon.stub(bunClient.shell, 'exec');
+
+  exec.onFirstCall().rejects(new Error('Initial error with one-time pass.'));
+  exec.onSecondCall().rejects(new Error('The provided one-time pass is incorrect.'));
+  exec.onThirdCall().resolves();
+
+  await bunClient.publish({
+    otpCallback: () =>
+      bunClient.publish({
+        otp: '123',
+        otpCallback: () => bunClient.publish({ otp: '123456' })
+      })
+  });
+
+  t.is(exec.callCount, 3);
+  t.is(exec.firstCall.args[0].trim(), 'bun publish . --tag latest');
+  t.is(exec.secondCall.args[0].trim(), 'bun publish . --tag latest --otp 123');
+  t.is(exec.thirdCall.args[0].trim(), 'bun publish . --tag latest --otp 123456');
+
+  t.is(bunClient.log.warn.callCount, 1);
+  t.is(bunClient.log.warn.firstCall.args[0], 'The provided OTP is incorrect or has expired.');
+});
+
+test('should publish', async t => {
+  const bunClient = factory(bun);
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').resolves('john');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) release-it/)
+    .resolves(JSON.stringify({ john: ['write'] }));
+  await runTasks(bunClient);
+  t.is(exec.lastCall.args[0].trim(), 'bun publish . --tag latest');
+  exec.restore();
+});
+
+test('should use extra publish arguments ', async t => {
+  const options = { bun: { skipChecks: true, publishArgs: '--registry=http://my-internal-registry.local' } };
+  const bunClient = factory(bun, { options });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  await runTasks(bunClient);
+  t.is(exec.lastCall.args[0].trim(), 'bun publish . --tag latest --registry=http://my-internal-registry.local');
+  exec.restore();
+});
+
+test('should skip checks', async t => {
+  const options = { bun: { skipChecks: true } };
+  const bunClient = factory(bun, { options });
+  await t.notThrowsAsync(bunClient.init());
+});
+
+test('should publish to a different/scoped registry', async t => {
+  const resetFs = mockFs({
+    [path.resolve('package.json')]: JSON.stringify({
+      name: '@my-scope/my-pkg',
+      version: '1.0.0',
+      publishConfig: {
+        access: 'public',
+        '@my-scope:registry': 'https://gitlab.com/api/v4/projects/my-scope%2Fmy-pkg/packages/bun/'
+      }
+    })
+  });
+  const options = { bun };
+  const bunClient = factory(bun, { options });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec
+    .withArgs('bun whoami --registry https://gitlab.com/api/v4/projects/my-scope%2Fmy-pkg/packages/bun/')
+    .resolves('john');
+  exec
+    .withArgs(
+      /bun access (list collaborators --json|ls-collaborators) @my-scope\/my-pkg --registry https:\/\/gitlab\.com\/api\/v4\/projects\/my-scope%2Fmy-pkg\/packages\/bun\//
+    )
+    .resolves(JSON.stringify({ john: ['write'] }));
+
+  await runTasks(bunClient);
+
+  t.deepEqual(getArgs(exec.args, 'bun'), [
+    'bun ping --registry https://gitlab.com/api/v4/projects/my-scope%2Fmy-pkg/packages/bun/',
+    'bun whoami --registry https://gitlab.com/api/v4/projects/my-scope%2Fmy-pkg/packages/bun/',
+    'bun show @my-scope/my-pkg@latest version --registry https://gitlab.com/api/v4/projects/my-scope%2Fmy-pkg/packages/bun/',
+    'bun --version',
+    'bun version 1.0.1 --no-git-tag-version',
+    'bun publish . --tag latest --registry https://gitlab.com/api/v4/projects/my-scope%2Fmy-pkg/packages/bun/'
+  ]);
+
+  exec.restore();
+  resetFs();
+});
+
+test('should not publish when `bun version` fails', async t => {
+  const resetFs = mockFs({
+    [path.resolve('package.json')]: JSON.stringify({
+      name: '@my-scope/my-pkg',
+      version: '1.0.0'
+    })
+  });
+  const options = { bun };
+  const bunClient = factory(bun, { options });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  exec.withArgs('bun whoami').resolves('john');
+  exec
+    .withArgs(/bun access (list collaborators --json|ls-collaborators) @my-scope\/my-pkg/)
+    .resolves(JSON.stringify({ john: ['write'] }));
+  exec
+    .withArgs('bun version 1.0.1 --no-git-tag-version')
+    .rejects('bun ERR! Version not changed, might want --allow-same-version');
+
+  try {
+    await runTasks(bunClient);
+  } catch (error) {
+    t.regex(error.toString(), /Version not changed/);
+  }
+
+  t.deepEqual(getArgs(exec.args, 'bun'), [
+    'bun ping',
+    'bun whoami',
+    'bun show @my-scope/my-pkg@latest version',
+    'bun --version',
+    'bun version 1.0.1 --no-git-tag-version'
+  ]);
+
+  exec.restore();
+  resetFs();
+});
+
+test('should add allow-same-version argument', async t => {
+  const options = { bun: { skipChecks: true, allowSameVersion: true } };
+  const bunClient = factory(bun, { options });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  await runTasks(bunClient);
+  const version = exec.args.filter(arg => arg[0].startsWith('bun version'));
+  t.regex(version[0][0], / --allow-same-version/);
+});
+
+test('should add version arguments', async t => {
+  const options = { bun: { skipChecks: true, versionArgs: ['--workspaces-update=false', '--allow-same-version'] } };
+  const bunClient = factory(bun, { options });
+  const exec = sinon.stub(bunClient.shell, 'exec').resolves();
+  await runTasks(bunClient);
+  const version = exec.args.filter(arg => arg[0].startsWith('bun version'));
+  t.regex(version[0][0], / --workspaces-update=false --allow-same-version/);
+});
diff --git a/node_modules/release-it/types/config.d.ts b/node_modules/release-it/types/config.d.ts
index 2034157..9250153 100644
--- a/node_modules/release-it/types/config.d.ts
+++ b/node_modules/release-it/types/config.d.ts
@@ -98,6 +98,36 @@ export interface Config {
     timeout?: number;
   };
 
+  bun?: {
+    /** @default false */
+    publish?: boolean;
+
+    /** @default "." */
+    publishPath?: string;
+
+    publishArgs?: Array<any>;
+
+    /** @default null */
+    tag?: any;
+
+    /** @default null */
+    otp?: any;
+
+    /** @default false */
+    ignoreVersion?: boolean;
+
+    /** @default false */
+    allowSameVersion?: boolean;
+
+    versionArgs?: Array<any>;
+
+    /** @default false */
+    skipChecks?: boolean;
+
+    /** @default 10 */
+    timeout?: number;
+  };
+
   github?: {
     /** @default false */
     release?: boolean;
