///
/// RNQuickSQLite-Swift-Cxx-Bridge.hpp
/// Sun Sep 01 2024
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `Transaction` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct Transaction; }

// Include C++ defined types
#include "Transaction.hpp"
#include <NitroModules/PromiseHolder.hpp>
#include <functional>
#include <future>
#include <memory>
#include <string>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::rnquicksqlite::bridge::swift {

  /**
   * Specialized version of `std::function<void(const std::string& / * dbName * /, const std::string& / * location * /)>`.
   */
  using Func_void_std__string_std__string = std::function<void(const std::string& /* dbName */, const std::string& /* location */)>;
  inline Func_void_std__string_std__string create_Func_void_std__string_std__string(void* closureHolder, void(*call)(void* /* closureHolder */, std::string, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::string& location) -> void {
      call(sharedClosureHolder.get(), dbName, location);
    };
  }
  inline std::shared_ptr<Func_void_std__string_std__string> share_Func_void_std__string_std__string(const Func_void_std__string_std__string& value) {
    return std::make_shared<Func_void_std__string_std__string>(value);
  }
  
  /**
   * Specialized version of `std::function<void(const std::string& / * dbName * /)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* dbName */)>;
  inline Func_void_std__string create_Func_void_std__string(void* closureHolder, void(*call)(void* /* closureHolder */, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName) -> void {
      call(sharedClosureHolder.get(), dbName);
    };
  }
  inline std::shared_ptr<Func_void_std__string> share_Func_void_std__string(const Func_void_std__string& value) {
    return std::make_shared<Func_void_std__string>(value);
  }
  
  /**
   * Specialized version of `std::function<void(const std::string& / * mainDbName * /, const std::string& / * dbNameToAttach * /, const std::string& / * alias * /, const std::string& / * location * /)>`.
   */
  using Func_void_std__string_std__string_std__string_std__string = std::function<void(const std::string& /* mainDbName */, const std::string& /* dbNameToAttach */, const std::string& /* alias */, const std::string& /* location */)>;
  inline Func_void_std__string_std__string_std__string_std__string create_Func_void_std__string_std__string_std__string_std__string(void* closureHolder, void(*call)(void* /* closureHolder */, std::string, std::string, std::string, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& mainDbName, const std::string& dbNameToAttach, const std::string& alias, const std::string& location) -> void {
      call(sharedClosureHolder.get(), mainDbName, dbNameToAttach, alias, location);
    };
  }
  inline std::shared_ptr<Func_void_std__string_std__string_std__string_std__string> share_Func_void_std__string_std__string_std__string_std__string(const Func_void_std__string_std__string_std__string_std__string& value) {
    return std::make_shared<Func_void_std__string_std__string_std__string_std__string>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<void>`.
   */
  using PromiseHolder_void_ = PromiseHolder<void>;
  inline PromiseHolder<void> create_PromiseHolder_void_() {
    return PromiseHolder<void>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<void>>(const Transaction& / * tx * /)>`.
   */
  using Func_std__future_std__future_void___Transaction = std::function<std::future<std::future<void>>(const Transaction& /* tx */)>;
  inline Func_std__future_std__future_void___Transaction create_Func_std__future_std__future_void___Transaction(void* closureHolder, PromiseHolder<std::future<void>>(*call)(void* /* closureHolder */, Transaction), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const Transaction& tx) -> std::future<std::future<void>> {
      auto result = call(sharedClosureHolder.get(), tx);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_void___Transaction> share_Func_std__future_std__future_void___Transaction(const Func_std__future_std__future_void___Transaction& value) {
    return std::make_shared<Func_std__future_std__future_void___Transaction>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<void>>`.
   */
  using PromiseHolder_std__future_void__ = PromiseHolder<std::future<void>>;
  inline PromiseHolder<std::future<void>> create_PromiseHolder_std__future_void__() {
    return PromiseHolder<std::future<void>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<void>>(const std::string& / * dbName * /, const std::function<std::future<std::future<void>>(const Transaction& / * tx * /)>& / * fn * /)>`.
   */
  using Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____ = std::function<std::future<std::future<void>>(const std::string& /* dbName */, const std::function<std::future<std::future<void>>(const Transaction& /* tx */)>& /* fn */)>;
  inline Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____ create_Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____(void* closureHolder, PromiseHolder<std::future<void>>(*call)(void* /* closureHolder */, std::string, std::function<std::future<std::future<void>>(const Transaction& /* tx */)>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::function<std::future<std::future<void>>(const Transaction& /* tx */)>& fn) -> std::future<std::future<void>> {
      auto result = call(sharedClosureHolder.get(), dbName, fn);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____> share_Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____(const Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____& value) {
    return std::make_shared<Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____>(value);
  }

} // namespace margelo::nitro::rnquicksqlite::bridge::swift
