///
/// RNQuickSQLite-Swift-Cxx-Bridge.hpp
/// Tue Sep 10 2024
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `ArrayBufferHolder` to properly resolve imports.
namespace NitroModules { class ArrayBufferHolder; }
// Forward declaration of `ArrayBuffer` to properly resolve imports.
namespace NitroModules { class ArrayBuffer; }
// Forward declaration of `BatchQueryCommand` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct BatchQueryCommand; }
// Forward declaration of `BatchQueryResult` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct BatchQueryResult; }
// Forward declaration of `ColumnMetadata` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct ColumnMetadata; }
// Forward declaration of `ColumnType` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { enum class ColumnType; }
// Forward declaration of `FileLoadResult` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct FileLoadResult; }
// Forward declaration of `HybridSelectQueryResultSpecSwift` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { class HybridSelectQueryResultSpecSwift; }
// Forward declaration of `HybridSelectQueryResultSpec` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { class HybridSelectQueryResultSpec; }
// Forward declaration of `QueryResult` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct QueryResult; }
// Forward declaration of `QueryType` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { enum class QueryType; }
// Forward declaration of `Transaction` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct Transaction; }

// Include C++ defined types
#if __has_include("BatchQueryCommand.hpp")
 #include "BatchQueryCommand.hpp"
#endif
#if __has_include("BatchQueryResult.hpp")
 #include "BatchQueryResult.hpp"
#endif
#if __has_include("ColumnMetadata.hpp")
 #include "ColumnMetadata.hpp"
#endif
#if __has_include("ColumnType.hpp")
 #include "ColumnType.hpp"
#endif
#if __has_include("FileLoadResult.hpp")
 #include "FileLoadResult.hpp"
#endif
#if __has_include("HybridSelectQueryResultSpec.hpp")
 #include "HybridSelectQueryResultSpec.hpp"
#endif
#if __has_include("HybridSelectQueryResultSpecSwift.hpp")
 #include "HybridSelectQueryResultSpecSwift.hpp"
#endif
#if __has_include("QueryResult.hpp")
 #include "QueryResult.hpp"
#endif
#if __has_include("QueryType.hpp")
 #include "QueryType.hpp"
#endif
#if __has_include("Transaction.hpp")
 #include "Transaction.hpp"
#endif
#if __has_include(<NitroModules/ArrayBuffer.hpp>)
 #include <NitroModules/ArrayBuffer.hpp>
#endif
#if __has_include(<NitroModules/ArrayBufferHolder.hpp>)
 #include <NitroModules/ArrayBufferHolder.hpp>
#endif
#if __has_include(<NitroModules/PromiseHolder.hpp>)
 #include <NitroModules/PromiseHolder.hpp>
#endif
#if __has_include(<functional>)
 #include <functional>
#endif
#if __has_include(<future>)
 #include <future>
#endif
#if __has_include(<memory>)
 #include <memory>
#endif
#if __has_include(<optional>)
 #include <optional>
#endif
#if __has_include(<string>)
 #include <string>
#endif
#if __has_include(<unordered_map>)
 #include <unordered_map>
#endif
#if __has_include(<variant>)
 #include <variant>
#endif
#if __has_include(<vector>)
 #include <vector>
#endif

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::rnquicksqlite::bridge::swift {

  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) {
    return std::optional<std::string>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<void>`.
   */
  using PromiseHolder_void_ = PromiseHolder<void>;
  inline PromiseHolder<void> create_PromiseHolder_void_() {
    return PromiseHolder<void>();
  }
  
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) {
    return std::optional<double>(value);
  }
  
  /**
   * Specialized version of `std::optional<std::shared_ptr<margelo::nitro::rnquicksqlite::HybridSelectQueryResultSpec>>`.
   */
  using std__optional_std__shared_ptr_margelo__nitro__rnquicksqlite__HybridSelectQueryResultSpec__ = std::optional<std::shared_ptr<margelo::nitro::rnquicksqlite::HybridSelectQueryResultSpec>>;
  inline std::optional<std::shared_ptr<margelo::nitro::rnquicksqlite::HybridSelectQueryResultSpec>> create_std__optional_std__shared_ptr_margelo__nitro__rnquicksqlite__HybridSelectQueryResultSpec__(const std::shared_ptr<margelo::nitro::rnquicksqlite::HybridSelectQueryResultSpec>& value) {
    return std::optional<std::shared_ptr<margelo::nitro::rnquicksqlite::HybridSelectQueryResultSpec>>(value);
  }
  
  /**
   * Specialized version of `std::function<std::future<QueryResult>()>`.
   */
  using Func_std__future_QueryResult_ = std::function<std::future<QueryResult>()>;
  /**
   * Wrapper class for a `std::function<std::future<QueryResult>()>`, this can be used from Swift.
   */
  class Func_std__future_QueryResult__Wrapper {
  public:
    explicit Func_std__future_QueryResult__Wrapper(const std::function<std::future<QueryResult>()>& func): function(func) {}
    explicit Func_std__future_QueryResult__Wrapper(std::function<std::future<QueryResult>()>&& func): function(std::move(func)) {}
  
    PromiseHolder<QueryResult> call() const {
      auto result = function();
      return []() -> PromiseHolder<QueryResult> { throw std::runtime_error("Promise<..> cannot be converted to Swift yet!"); }();
    }
  
    std::function<std::future<QueryResult>()> function;
  };
  inline Func_std__future_QueryResult_ create_Func_std__future_QueryResult_(void* closureHolder, PromiseHolder<QueryResult>(*call)(void* /* closureHolder */), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return Func_std__future_QueryResult_([sharedClosureHolder, call]() -> std::future<QueryResult> {
      auto result = call(sharedClosureHolder.get());
      return result.getFuture();
    });
  }
  inline std::shared_ptr<Func_std__future_QueryResult__Wrapper> share_Func_std__future_QueryResult_(const Func_std__future_QueryResult_& value) {
    return std::make_shared<Func_std__future_QueryResult__Wrapper>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<QueryResult>`.
   */
  using PromiseHolder_QueryResult_ = PromiseHolder<QueryResult>;
  inline PromiseHolder<QueryResult> create_PromiseHolder_QueryResult_() {
    return PromiseHolder<QueryResult>();
  }
  
  /**
   * Specialized version of `std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>`.
   */
  using std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ = std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>;
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const std::string& value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(double value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(int64_t value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(bool value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const std::shared_ptr<ArrayBuffer>& value) {
    return value;
  }
  inline std::string get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___0(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<0>(variant);
  }
  inline double get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___1(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<1>(variant);
  }
  inline int64_t get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___2(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<2>(variant);
  }
  inline bool get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___3(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<3>(variant);
  }
  inline std::shared_ptr<ArrayBuffer> get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___4(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<4>(variant);
  }
  
  /**
   * Specialized version of `std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>`.
   */
  using std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ = std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>;
  inline std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> create_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(size_t size) {
    std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::function<std::future<QueryResult>(const std::string&, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>&)>`.
   */
  using Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ = std::function<std::future<QueryResult>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)>;
  /**
   * Wrapper class for a `std::function<std::future<QueryResult>(const std::string& / * query * /, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& / * params * /)>`, this can be used from Swift.
   */
  class Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper {
  public:
    explicit Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper(const std::function<std::future<QueryResult>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)>& func): function(func) {}
    explicit Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper(std::function<std::future<QueryResult>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)>&& func): function(std::move(func)) {}
  
    PromiseHolder<QueryResult> call(std::string query, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> params) const {
      auto result = function(query, params);
      return []() -> PromiseHolder<QueryResult> { throw std::runtime_error("Promise<..> cannot be converted to Swift yet!"); }();
    }
  
    std::function<std::future<QueryResult>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)> function;
  };
  inline Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ create_Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(void* closureHolder, PromiseHolder<QueryResult>(*call)(void* /* closureHolder */, std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___([sharedClosureHolder, call](const std::string& query, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& params) -> std::future<QueryResult> {
      auto result = call(sharedClosureHolder.get(), query, params);
      return result.getFuture();
    });
  }
  inline std::shared_ptr<Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper> share_Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(const Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___& value) {
    return std::make_shared<Func_std__future_QueryResult__std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper>(value);
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<QueryResult>>(const std::string&, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>&)>`.
   */
  using Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ = std::function<std::future<std::future<QueryResult>>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)>;
  /**
   * Wrapper class for a `std::function<std::future<std::future<QueryResult>>(const std::string& / * query * /, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& / * params * /)>`, this can be used from Swift.
   */
  class Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper {
  public:
    explicit Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper(const std::function<std::future<std::future<QueryResult>>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)>& func): function(func) {}
    explicit Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper(std::function<std::future<std::future<QueryResult>>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)>&& func): function(std::move(func)) {}
  
    PromiseHolder<std::future<QueryResult>> call(std::string query, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> params) const {
      auto result = function(query, params);
      return []() -> PromiseHolder<std::future<QueryResult>> { throw std::runtime_error("Promise<..> cannot be converted to Swift yet!"); }();
    }
  
    std::function<std::future<std::future<QueryResult>>(const std::string& /* query */, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& /* params */)> function;
  };
  inline Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ create_Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(void* closureHolder, PromiseHolder<std::future<QueryResult>>(*call)(void* /* closureHolder */, std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___([sharedClosureHolder, call](const std::string& query, const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& params) -> std::future<std::future<QueryResult>> {
      auto result = call(sharedClosureHolder.get(), query, params);
      return result.getFuture();
    });
  }
  inline std::shared_ptr<Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper> share_Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(const Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___& value) {
    return std::make_shared<Func_std__future_std__future_QueryResult___std__string_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____Wrapper>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<QueryResult>>`.
   */
  using PromiseHolder_std__future_QueryResult__ = PromiseHolder<std::future<QueryResult>>;
  inline PromiseHolder<std::future<QueryResult>> create_PromiseHolder_std__future_QueryResult__() {
    return PromiseHolder<std::future<QueryResult>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<void>>(const Transaction&)>`.
   */
  using Func_std__future_std__future_void___Transaction = std::function<std::future<std::future<void>>(const Transaction& /* tx */)>;
  /**
   * Wrapper class for a `std::function<std::future<std::future<void>>(const Transaction& / * tx * /)>`, this can be used from Swift.
   */
  class Func_std__future_std__future_void___Transaction_Wrapper {
  public:
    explicit Func_std__future_std__future_void___Transaction_Wrapper(const std::function<std::future<std::future<void>>(const Transaction& /* tx */)>& func): function(func) {}
    explicit Func_std__future_std__future_void___Transaction_Wrapper(std::function<std::future<std::future<void>>(const Transaction& /* tx */)>&& func): function(std::move(func)) {}
  
    PromiseHolder<std::future<void>> call(Transaction tx) const {
      auto result = function(tx);
      return []() -> PromiseHolder<std::future<void>> { throw std::runtime_error("Promise<..> cannot be converted to Swift yet!"); }();
    }
  
    std::function<std::future<std::future<void>>(const Transaction& /* tx */)> function;
  };
  inline Func_std__future_std__future_void___Transaction create_Func_std__future_std__future_void___Transaction(void* closureHolder, PromiseHolder<std::future<void>>(*call)(void* /* closureHolder */, Transaction), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return Func_std__future_std__future_void___Transaction([sharedClosureHolder, call](const Transaction& tx) -> std::future<std::future<void>> {
      auto result = call(sharedClosureHolder.get(), tx);
      return result.getFuture();
    });
  }
  inline std::shared_ptr<Func_std__future_std__future_void___Transaction_Wrapper> share_Func_std__future_std__future_void___Transaction(const Func_std__future_std__future_void___Transaction& value) {
    return std::make_shared<Func_std__future_std__future_void___Transaction_Wrapper>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<void>>`.
   */
  using PromiseHolder_std__future_void__ = PromiseHolder<std::future<void>>;
  inline PromiseHolder<std::future<void>> create_PromiseHolder_std__future_void__() {
    return PromiseHolder<std::future<void>>();
  }
  
  /**
   * Specialized version of `std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>`.
   */
  using std__optional_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____ = std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>;
  inline std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> create_std__optional_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____(const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& value) {
    return std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>(value);
  }
  
  /**
   * Specialized version of `std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>`.
   */
  using std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____ = std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>;
  inline std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> create_std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____(size_t size) {
    std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>`.
   */
  using std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____ = std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>;
  inline std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>> create_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& value) {
    return value;
  }
  inline std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>> create_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(const std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>& value) {
    return value;
  }
  inline std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> get_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______0(const std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>& variant) {
    return std::get<0>(variant);
  }
  inline std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> get_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______1(const std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>& variant) {
    return std::get<1>(variant);
  }
  
  /**
   * Specialized version of `std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>>`.
   */
  using std__optional_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______ = std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>>;
  inline std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>> create_std__optional_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______(const std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>& value) {
    return std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>>(value);
  }
  
  /**
   * Specialized version of `std::vector<BatchQueryCommand>`.
   */
  using std__vector_BatchQueryCommand_ = std::vector<BatchQueryCommand>;
  inline std::vector<BatchQueryCommand> create_std__vector_BatchQueryCommand_(size_t size) {
    std::vector<BatchQueryCommand> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `PromiseHolder<BatchQueryResult>`.
   */
  using PromiseHolder_BatchQueryResult_ = PromiseHolder<BatchQueryResult>;
  inline PromiseHolder<BatchQueryResult> create_PromiseHolder_BatchQueryResult_() {
    return PromiseHolder<BatchQueryResult>();
  }
  
  /**
   * Specialized version of `PromiseHolder<FileLoadResult>`.
   */
  using PromiseHolder_FileLoadResult_ = PromiseHolder<FileLoadResult>;
  inline PromiseHolder<FileLoadResult> create_PromiseHolder_FileLoadResult_() {
    return PromiseHolder<FileLoadResult>();
  }
  
  /**
   * Specialized version of `std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>`.
   */
  using std__unordered_map_std__string__std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____ = std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>;
  inline std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> create_std__unordered_map_std__string__std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____(size_t size) {
    std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____keys(const std__unordered_map_std__string__std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____& map) {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  
  /**
   * Specialized version of `std::optional<std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>`.
   */
  using std__optional_std__unordered_map_std__string__std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____ = std::optional<std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>;
  inline std::optional<std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>> create_std__optional_std__unordered_map_std__string__std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(const std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>& value) {
    return std::optional<std::unordered_map<std::string, std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>(value);
  }
  
  /**
   * Specialized version of `std::vector<ColumnMetadata>`.
   */
  using std__vector_ColumnMetadata_ = std::vector<ColumnMetadata>;
  inline std::vector<ColumnMetadata> create_std__vector_ColumnMetadata_(size_t size) {
    std::vector<ColumnMetadata> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::optional<std::vector<ColumnMetadata>>`.
   */
  using std__optional_std__vector_ColumnMetadata__ = std::optional<std::vector<ColumnMetadata>>;
  inline std::optional<std::vector<ColumnMetadata>> create_std__optional_std__vector_ColumnMetadata__(const std::vector<ColumnMetadata>& value) {
    return std::optional<std::vector<ColumnMetadata>>(value);
  }

} // namespace margelo::nitro::rnquicksqlite::bridge::swift
