///
/// RNQuickSQLite-Swift-Cxx-Bridge.hpp
/// Sun Sep 01 2024
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `ArrayBuffer` to properly resolve imports.
namespace NitroModules { class ArrayBuffer; }
// Forward declaration of `BatchQueryResult` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct BatchQueryResult; }
// Forward declaration of `ColumnMetadata` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct ColumnMetadata; }
// Forward declaration of `FileLoadResult` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct FileLoadResult; }
// Forward declaration of `QueryResultRow` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct QueryResultRow; }
// Forward declaration of `QueryResult` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct QueryResult; }
// Forward declaration of `Transaction` to properly resolve imports.
namespace margelo::nitro::rnquicksqlite { struct Transaction; }

// Include C++ defined types
#include "BatchQueryResult.hpp"
#include "ColumnMetadata.hpp"
#include "FileLoadResult.hpp"
#include "QueryResult.hpp"
#include "QueryResultRow.hpp"
#include "Transaction.hpp"
#include <NitroModules/ArrayBuffer.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <functional>
#include <future>
#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::rnquicksqlite::bridge::swift {

  /**
   * Specialized version of `std::function<void(const std::string& / * dbName * /, const std::string& / * location * /)>`.
   */
  using Func_void_std__string_std__string = std::function<void(const std::string& /* dbName */, const std::string& /* location */)>;
  inline Func_void_std__string_std__string create_Func_void_std__string_std__string(void* closureHolder, void(*call)(void* /* closureHolder */, std::string, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::string& location) -> void {
      call(sharedClosureHolder.get(), dbName, location);
    };
  }
  inline std::shared_ptr<Func_void_std__string_std__string> share_Func_void_std__string_std__string(const Func_void_std__string_std__string& value) {
    return std::make_shared<Func_void_std__string_std__string>(value);
  }
  
  /**
   * Specialized version of `std::function<void(const std::string& / * dbName * /)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* dbName */)>;
  inline Func_void_std__string create_Func_void_std__string(void* closureHolder, void(*call)(void* /* closureHolder */, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName) -> void {
      call(sharedClosureHolder.get(), dbName);
    };
  }
  inline std::shared_ptr<Func_void_std__string> share_Func_void_std__string(const Func_void_std__string& value) {
    return std::make_shared<Func_void_std__string>(value);
  }
  
  /**
   * Specialized version of `std::function<void(const std::string& / * mainDbName * /, const std::string& / * dbNameToAttach * /, const std::string& / * alias * /, const std::string& / * location * /)>`.
   */
  using Func_void_std__string_std__string_std__string_std__string = std::function<void(const std::string& /* mainDbName */, const std::string& /* dbNameToAttach */, const std::string& /* alias */, const std::string& /* location */)>;
  inline Func_void_std__string_std__string_std__string_std__string create_Func_void_std__string_std__string_std__string_std__string(void* closureHolder, void(*call)(void* /* closureHolder */, std::string, std::string, std::string, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& mainDbName, const std::string& dbNameToAttach, const std::string& alias, const std::string& location) -> void {
      call(sharedClosureHolder.get(), mainDbName, dbNameToAttach, alias, location);
    };
  }
  inline std::shared_ptr<Func_void_std__string_std__string_std__string_std__string> share_Func_void_std__string_std__string_std__string_std__string(const Func_void_std__string_std__string_std__string_std__string& value) {
    return std::make_shared<Func_void_std__string_std__string_std__string_std__string>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<void>`.
   */
  using PromiseHolder_void_ = PromiseHolder<void>;
  inline PromiseHolder<void> create_PromiseHolder_void_() {
    return PromiseHolder<void>();
  }
  
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) {
    return std::optional<double>(value);
  }
  
  /**
   * Specialized version of `std::vector<std::nullptr_t>`.
   */
  using std__vector_std__nullptr_t_ = std::vector<std::nullptr_t>;
  inline std::vector<std::nullptr_t> create_std__vector_std__nullptr_t_(size_t size) {
    std::vector<std::nullptr_t> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::function<std::future<std::nullptr_t>(double / * idx * /)>`.
   */
  using Func_std__future_std__nullptr_t__double = std::function<std::future<std::nullptr_t>(double /* idx */)>;
  inline Func_std__future_std__nullptr_t__double create_Func_std__future_std__nullptr_t__double(void* closureHolder, PromiseHolder<std::nullptr_t>(*call)(void* /* closureHolder */, double), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](double idx) -> std::future<std::nullptr_t> {
      auto result = call(sharedClosureHolder.get(), idx);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__nullptr_t__double> share_Func_std__future_std__nullptr_t__double(const Func_std__future_std__nullptr_t__double& value) {
    return std::make_shared<Func_std__future_std__nullptr_t__double>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::nullptr_t>`.
   */
  using PromiseHolder_std__nullptr_t_ = PromiseHolder<std::nullptr_t>;
  inline PromiseHolder<std::nullptr_t> create_PromiseHolder_std__nullptr_t_() {
    return PromiseHolder<std::nullptr_t>();
  }
  
  /**
   * Specialized version of `std::vector<QueryResultRow>`.
   */
  using std__vector_QueryResultRow_ = std::vector<QueryResultRow>;
  inline std::vector<QueryResultRow> create_std__vector_QueryResultRow_(size_t size) {
    std::vector<QueryResultRow> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::optional<std::vector<QueryResultRow>>`.
   */
  using std__optional_std__vector_QueryResultRow__ = std::optional<std::vector<QueryResultRow>>;
  inline std::optional<std::vector<QueryResultRow>> create_std__optional_std__vector_QueryResultRow__(const std::vector<QueryResultRow>& value) {
    return std::optional<std::vector<QueryResultRow>>(value);
  }
  
  /**
   * Specialized version of `std::vector<ColumnMetadata>`.
   */
  using std__vector_ColumnMetadata_ = std::vector<ColumnMetadata>;
  inline std::vector<ColumnMetadata> create_std__vector_ColumnMetadata_(size_t size) {
    std::vector<ColumnMetadata> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::optional<std::vector<ColumnMetadata>>`.
   */
  using std__optional_std__vector_ColumnMetadata__ = std::optional<std::vector<ColumnMetadata>>;
  inline std::optional<std::vector<ColumnMetadata>> create_std__optional_std__vector_ColumnMetadata__(const std::vector<ColumnMetadata>& value) {
    return std::optional<std::vector<ColumnMetadata>>(value);
  }
  
  /**
   * Specialized version of `std::function<std::future<QueryResult>()>`.
   */
  using Func_std__future_QueryResult_ = std::function<std::future<QueryResult>()>;
  inline Func_std__future_QueryResult_ create_Func_std__future_QueryResult_(void* closureHolder, PromiseHolder<QueryResult>(*call)(void* /* closureHolder */), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call]() -> std::future<QueryResult> {
      auto result = call(sharedClosureHolder.get());
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_QueryResult_> share_Func_std__future_QueryResult_(const Func_std__future_QueryResult_& value) {
    return std::make_shared<Func_std__future_QueryResult_>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<QueryResult>`.
   */
  using PromiseHolder_QueryResult_ = PromiseHolder<QueryResult>;
  inline PromiseHolder<QueryResult> create_PromiseHolder_QueryResult_() {
    return PromiseHolder<QueryResult>();
  }
  
  /**
   * Specialized version of `std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>`.
   */
  using std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ = std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>;
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const std::string& value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(double value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(int64_t value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(bool value) {
    return value;
  }
  inline std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const std::shared_ptr<ArrayBuffer>& value) {
    return value;
  }
  inline std::string get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___0(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<0>(variant);
  }
  inline double get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___1(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<1>(variant);
  }
  inline int64_t get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___2(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<2>(variant);
  }
  inline bool get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___3(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<3>(variant);
  }
  inline std::shared_ptr<ArrayBuffer> get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___4(const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<4>(variant);
  }
  
  /**
   * Specialized version of `std::function<std::future<QueryResult>(const std::string& / * query * /, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& / * params * /)>`.
   */
  using Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ = std::function<std::future<QueryResult>(const std::string& /* query */, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& /* params */)>;
  inline Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(void* closureHolder, PromiseHolder<QueryResult>(*call)(void* /* closureHolder */, std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& query, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& params) -> std::future<QueryResult> {
      auto result = call(sharedClosureHolder.get(), query, params);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__> share_Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& value) {
    return std::make_shared<Func_std__future_QueryResult__std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__>(value);
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<QueryResult>>(const std::string& / * query * /, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& / * params * /)>`.
   */
  using Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ = std::function<std::future<std::future<QueryResult>>(const std::string& /* query */, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& /* params */)>;
  inline Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(void* closureHolder, PromiseHolder<std::future<QueryResult>>(*call)(void* /* closureHolder */, std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& query, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& params) -> std::future<std::future<QueryResult>> {
      auto result = call(sharedClosureHolder.get(), query, params);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__> share_Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& value) {
    return std::make_shared<Func_std__future_std__future_QueryResult___std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<QueryResult>>`.
   */
  using PromiseHolder_std__future_QueryResult__ = PromiseHolder<std::future<QueryResult>>;
  inline PromiseHolder<std::future<QueryResult>> create_PromiseHolder_std__future_QueryResult__() {
    return PromiseHolder<std::future<QueryResult>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<void>>(const Transaction& / * tx * /)>`.
   */
  using Func_std__future_std__future_void___Transaction = std::function<std::future<std::future<void>>(const Transaction& /* tx */)>;
  inline Func_std__future_std__future_void___Transaction create_Func_std__future_std__future_void___Transaction(void* closureHolder, PromiseHolder<std::future<void>>(*call)(void* /* closureHolder */, Transaction), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const Transaction& tx) -> std::future<std::future<void>> {
      auto result = call(sharedClosureHolder.get(), tx);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_void___Transaction> share_Func_std__future_std__future_void___Transaction(const Func_std__future_std__future_void___Transaction& value) {
    return std::make_shared<Func_std__future_std__future_void___Transaction>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<void>>`.
   */
  using PromiseHolder_std__future_void__ = PromiseHolder<std::future<void>>;
  inline PromiseHolder<std::future<void>> create_PromiseHolder_std__future_void__() {
    return PromiseHolder<std::future<void>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<void>>(const std::string& / * dbName * /, const std::function<std::future<std::future<void>>(const Transaction& / * tx * /)>& / * fn * /)>`.
   */
  using Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____ = std::function<std::future<std::future<void>>(const std::string& /* dbName */, const std::function<std::future<std::future<void>>(const Transaction& /* tx */)>& /* fn */)>;
  inline Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____ create_Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____(void* closureHolder, PromiseHolder<std::future<void>>(*call)(void* /* closureHolder */, std::string, std::function<std::future<std::future<void>>(const Transaction& /* tx */)>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::function<std::future<std::future<void>>(const Transaction& /* tx */)>& fn) -> std::future<std::future<void>> {
      auto result = call(sharedClosureHolder.get(), dbName, fn);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____> share_Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____(const Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____& value) {
    return std::make_shared<Func_std__future_std__future_void___std__string_std__function_std__future_std__future_void___const_Transaction_____tx_____>(value);
  }
  
  /**
   * Specialized version of `std::function<std::future<QueryResult>(const std::string& / * dbName * /, const std::string& / * query * /, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& / * params * /)>`.
   */
  using Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ = std::function<std::future<QueryResult>(const std::string& /* dbName */, const std::string& /* query */, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& /* params */)>;
  inline Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(void* closureHolder, PromiseHolder<QueryResult>(*call)(void* /* closureHolder */, std::string, std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::string& query, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& params) -> std::future<QueryResult> {
      auto result = call(sharedClosureHolder.get(), dbName, query, params);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__> share_Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& value) {
    return std::make_shared<Func_std__future_QueryResult__std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__>(value);
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<QueryResult>>(const std::string& / * dbName * /, const std::string& / * query * /, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& / * params * /)>`.
   */
  using Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ = std::function<std::future<std::future<QueryResult>>(const std::string& /* dbName */, const std::string& /* query */, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& /* params */)>;
  inline Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(void* closureHolder, PromiseHolder<std::future<QueryResult>>(*call)(void* /* closureHolder */, std::string, std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::string& query, const std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>& params) -> std::future<std::future<QueryResult>> {
      auto result = call(sharedClosureHolder.get(), dbName, query, params);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__> share_Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& value) {
    return std::make_shared<Func_std__future_std__future_QueryResult___std__string_std__string_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__>(value);
  }
  
  /**
   * Specialized version of `std::tuple<std::string>`.
   */
  using std__tuple_std__string_ = std::tuple<std::string>;
  inline std::tuple<std::string> create_std__tuple_std__string_(const std::string& arg0) {
    return std::tuple<std::string> { arg0 };
  }
  
  /**
   * Specialized version of `std::vector<std::vector<std::nullptr_t>>`.
   */
  using std__vector_std__vector_std__nullptr_t__ = std::vector<std::vector<std::nullptr_t>>;
  inline std::vector<std::vector<std::nullptr_t>> create_std__vector_std__vector_std__nullptr_t__(size_t size) {
    std::vector<std::vector<std::nullptr_t>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>`.
   */
  using std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t___ = std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>;
  inline std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>> create_std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t___(const std::vector<std::nullptr_t>& value) {
    return value;
  }
  inline std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>> create_std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t___(const std::vector<std::vector<std::nullptr_t>>& value) {
    return value;
  }
  inline std::vector<std::nullptr_t> get_std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t____0(const std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>& variant) {
    return std::get<0>(variant);
  }
  inline std::vector<std::vector<std::nullptr_t>> get_std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t____1(const std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>& variant) {
    return std::get<1>(variant);
  }
  
  /**
   * Specialized version of `std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>`.
   */
  using std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t____ = std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>;
  inline std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>> create_std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t____(const std::string& arg0, const std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>& arg1) {
    return std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>> { arg0, arg1 };
  }
  
  /**
   * Specialized version of `std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>`.
   */
  using std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t_____ = std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>;
  inline std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>> create_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t_____(const std::tuple<std::string>& value) {
    return value;
  }
  inline std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>> create_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t_____(const std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>& value) {
    return value;
  }
  inline std::tuple<std::string> get_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______0(const std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>& variant) {
    return std::get<0>(variant);
  }
  inline std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>> get_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______1(const std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>& variant) {
    return std::get<1>(variant);
  }
  
  /**
   * Specialized version of `std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>`.
   */
  using std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______ = std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>;
  inline std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>> create_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______(size_t size) {
    std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::function<std::future<BatchQueryResult>(const std::string& / * dbName * /, const std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>& / * commands * /)>`.
   */
  using Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______ = std::function<std::future<BatchQueryResult>(const std::string& /* dbName */, const std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>& /* commands */)>;
  inline Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______ create_Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______(void* closureHolder, PromiseHolder<BatchQueryResult>(*call)(void* /* closureHolder */, std::string, std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>& commands) -> std::future<BatchQueryResult> {
      auto result = call(sharedClosureHolder.get(), dbName, commands);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______> share_Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______(const Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______& value) {
    return std::make_shared<Func_std__future_BatchQueryResult__std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<BatchQueryResult>`.
   */
  using PromiseHolder_BatchQueryResult_ = PromiseHolder<BatchQueryResult>;
  inline PromiseHolder<BatchQueryResult> create_PromiseHolder_BatchQueryResult_() {
    return PromiseHolder<BatchQueryResult>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<BatchQueryResult>>(const std::string& / * dbName * /, const std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>& / * commands * /)>`.
   */
  using Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______ = std::function<std::future<std::future<BatchQueryResult>>(const std::string& /* dbName */, const std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>& /* commands */)>;
  inline Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______ create_Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______(void* closureHolder, PromiseHolder<std::future<BatchQueryResult>>(*call)(void* /* closureHolder */, std::string, std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::vector<std::variant<std::tuple<std::string>, std::tuple<std::string, std::variant<std::vector<std::nullptr_t>, std::vector<std::vector<std::nullptr_t>>>>>>& commands) -> std::future<std::future<BatchQueryResult>> {
      auto result = call(sharedClosureHolder.get(), dbName, commands);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______> share_Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______(const Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______& value) {
    return std::make_shared<Func_std__future_std__future_BatchQueryResult___std__string_std__vector_std__variant_std__tuple_std__string___std__tuple_std__string__std__variant_std__vector_std__nullptr_t___std__vector_std__vector_std__nullptr_t______>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<BatchQueryResult>>`.
   */
  using PromiseHolder_std__future_BatchQueryResult__ = PromiseHolder<std::future<BatchQueryResult>>;
  inline PromiseHolder<std::future<BatchQueryResult>> create_PromiseHolder_std__future_BatchQueryResult__() {
    return PromiseHolder<std::future<BatchQueryResult>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<FileLoadResult>(const std::string& / * dbName * /, const std::string& / * location * /)>`.
   */
  using Func_std__future_FileLoadResult__std__string_std__string = std::function<std::future<FileLoadResult>(const std::string& /* dbName */, const std::string& /* location */)>;
  inline Func_std__future_FileLoadResult__std__string_std__string create_Func_std__future_FileLoadResult__std__string_std__string(void* closureHolder, PromiseHolder<FileLoadResult>(*call)(void* /* closureHolder */, std::string, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::string& location) -> std::future<FileLoadResult> {
      auto result = call(sharedClosureHolder.get(), dbName, location);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_FileLoadResult__std__string_std__string> share_Func_std__future_FileLoadResult__std__string_std__string(const Func_std__future_FileLoadResult__std__string_std__string& value) {
    return std::make_shared<Func_std__future_FileLoadResult__std__string_std__string>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<FileLoadResult>`.
   */
  using PromiseHolder_FileLoadResult_ = PromiseHolder<FileLoadResult>;
  inline PromiseHolder<FileLoadResult> create_PromiseHolder_FileLoadResult_() {
    return PromiseHolder<FileLoadResult>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<FileLoadResult>>(const std::string& / * dbName * /, const std::string& / * location * /)>`.
   */
  using Func_std__future_std__future_FileLoadResult___std__string_std__string = std::function<std::future<std::future<FileLoadResult>>(const std::string& /* dbName */, const std::string& /* location */)>;
  inline Func_std__future_std__future_FileLoadResult___std__string_std__string create_Func_std__future_std__future_FileLoadResult___std__string_std__string(void* closureHolder, PromiseHolder<std::future<FileLoadResult>>(*call)(void* /* closureHolder */, std::string, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return [sharedClosureHolder, call](const std::string& dbName, const std::string& location) -> std::future<std::future<FileLoadResult>> {
      auto result = call(sharedClosureHolder.get(), dbName, location);
      return result.getFuture();
    };
  }
  inline std::shared_ptr<Func_std__future_std__future_FileLoadResult___std__string_std__string> share_Func_std__future_std__future_FileLoadResult___std__string_std__string(const Func_std__future_std__future_FileLoadResult___std__string_std__string& value) {
    return std::make_shared<Func_std__future_std__future_FileLoadResult___std__string_std__string>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<FileLoadResult>>`.
   */
  using PromiseHolder_std__future_FileLoadResult__ = PromiseHolder<std::future<FileLoadResult>>;
  inline PromiseHolder<std::future<FileLoadResult>> create_PromiseHolder_std__future_FileLoadResult__() {
    return PromiseHolder<std::future<FileLoadResult>>();
  }

} // namespace margelo::nitro::rnquicksqlite::bridge::swift
